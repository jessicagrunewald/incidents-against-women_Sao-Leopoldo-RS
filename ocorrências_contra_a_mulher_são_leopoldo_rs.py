# -*- coding: utf-8 -*-
"""Ocorr√™ncias contra a mulher - S√£o Leopoldo-RS

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fxVJwq6qx_psoZUstrnnnUSXXksVUqaB

# üîß **Configura√ß√µes iniciais**
"""

from google.colab import drive
drive.mount('/content/drive')

"""# üìö **Bibliotecas**"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
import seaborn as sns

"""# üìï **Leitura do arquivo**"""

df_sl = pd.read_csv('/content/drive/My Drive/Data/ocorrencias_2021_2024_sl_editado.csv', sep = ",", encoding='utf-8')

"""# üìä **An√°lise descritiva - Crimes contra a mulher em S√£o Leopoldo**

### Edi√ß√µes
"""

# Excluir todas as linhas onde a coluna 'Bairro Classifica√ß√£o' seja igual a 'SEM INFORMACAO' ou 'MORRO DO PAULA'
df_sl = df_sl[~df_sl['Bairro Classifica√ß√£o'].isin(['SEM INFORMACAO', 'MORRO DO PAULA'])]

# Filtrar apenas os crimes contra mulheres, excluindo "Outros" e "Furto/Roubo"
df_filtered = df_sl[(df_sl['Classifica√ß√£o Seguran√ßa Mulheres'] != 'Outros') &
                    (df_sl['Classifica√ß√£o Seguran√ßa Mulheres'] != 'Furto/Roubo')]

# Contar o total de crimes por bairro
total_crimes_contra_mulher = df_filtered['Bairro Classifica√ß√£o'].value_counts().reset_index()
total_crimes_contra_mulher.columns = ['Bairro Classifica√ß√£o', 'Total de Crimes']

# Normalizar os nomes dos bairros em total_crimes_contra_mulher
total_crimes_contra_mulher['Bairro Classifica√ß√£o'] = (
    total_crimes_contra_mulher['Bairro Classifica√ß√£o']
    .str.lower()
    .str.replace(' ', '-')
)

"""## **üåé Mapa de S√£o Leopoldo**"""

# Importar as bibliotecas necess√°rias
import os
import folium
import geopandas as gpd
from folium import Choropleth
from folium.features import Choropleth

# Caminho para a pasta com os arquivos GeoJSON
pasta_mapa = '/content/drive/MyDrive/Data/MapaSL'
arquivos_geojson = [f for f in os.listdir(pasta_mapa) if f.endswith('.geojson')]

# Lista para armazenar cada GeoDataFrame tempor√°rio
geodados = []

for arquivo in arquivos_geojson:
    caminho = os.path.join(pasta_mapa, arquivo)
    gdf_temp = gpd.read_file(caminho)
    # Extrai o nome do bairro do nome do arquivo
    nome_bairro = os.path.splitext(arquivo)[0]
    gdf_temp['nome_bairro'] = nome_bairro
    geodados.append(gdf_temp)

# Concatena todos os GeoDataFrames em um s√≥
gdf_combined = gpd.GeoDataFrame(pd.concat(geodados, ignore_index=True))

"""### Mapa - Crimes contra a mulher"""

# Normalizar os nomes dos bairros
total_crimes_contra_mulher['Bairro Classifica√ß√£o'] = (
    total_crimes_contra_mulher['Bairro Classifica√ß√£o']
    .str.strip()
    .str.title()
)
gdf_combined['nome_bairro'] = gdf_combined['nome_bairro'].str.strip().str.title()

# Mapa base de S√£o Leopoldo
mapa_sl_contra_mulher = folium.Map(location=[-29.7549, -51.1498], zoom_start=12)

# Adicionar o mapa coropl√©tico
Choropleth(
    geo_data=gdf_combined,
    name="Choropleth",
    data=total_crimes_contra_mulher,
    columns=["Bairro Classifica√ß√£o", "Total de Crimes"],
    key_on="feature.properties.nome_bairro",
    fill_color="YlOrRd",
    fill_opacity=0.7,
    line_opacity=0.9,
    line_color="black",
    legend_name="Total de Crimes contra Mulheres",
    nan_fill_color="white"
).add_to(mapa_sl_contra_mulher)

# Adicionar o nome de cada bairro no centro da √°rea
for _, row in gdf_combined.iterrows():
    # Calcular o centroide de cada bairro
    centroid = row['geometry'].centroid
    nome_bairro = row['nome_bairro'].replace('-', ' ')
    folium.Marker(
        location=[centroid.y, centroid.x],
        icon=folium.DivIcon(html=f"""<div style="font-size: 12px; color: black;">{nome_bairro}</div>""")
    ).add_to(mapa_sl_contra_mulher)

folium.LayerControl().add_to(mapa_sl_contra_mulher)

# Exibir o mapa
mapa_sl_contra_mulher

"""### Mapa - Crimes contra a mulher (Porcentagem)"""

# Calcular a porcentagem de crimes contra mulheres para cada bairro
total_crimes_contra_mulher['Porcentagem Crimes Contra Mulher'] = (
    total_crimes_contra_mulher['Total de Crimes'] / total_crimes_contra_mulher['Total de Crimes'].sum() * 100
)

# Mesclar a porcentagem de crimes ao GeoDataFrame
gdf_combined = gdf_combined.merge(total_crimes_contra_mulher, left_on="nome_bairro", right_on="Bairro Classifica√ß√£o", how="left")

# Mapa base de S√£o Leopoldo
mapa_sl_contra_mulher = folium.Map(location=[-29.7549, -51.1498], zoom_start=12)

# Adicionar o mapa coropl√©tico
Choropleth(
    geo_data=gdf_combined,
    name="Choropleth",
    data=total_crimes_contra_mulher,
    columns=["Bairro Classifica√ß√£o", "Total de Crimes"],
    key_on="feature.properties.nome_bairro",
    fill_color="YlOrRd",
    fill_opacity=0.7,
    line_opacity=0.9,
    line_color="black",
    legend_name="Total de Crimes contra Mulheres",
    nan_fill_color="white"
).add_to(mapa_sl_contra_mulher)

# Adicionar o nome de cada bairro e a porcentagem de crimes no centro da √°rea
for _, row in gdf_combined.iterrows():
    # Calcular o centroide de cada bairro
    centroid = row['geometry'].centroid
    nome_bairro = row['nome_bairro'].replace('-', ' ')
    porcentagem = row['Porcentagem Crimes Contra Mulher'] if pd.notnull(row['Porcentagem Crimes Contra Mulher']) else 0
    folium.Marker(
        location=[centroid.y, centroid.x],
        icon=folium.DivIcon(html=f"""<div style="font-size: 12px; color: black;">
                                     {nome_bairro}<br>{porcentagem:.2f}%</div>""")
    ).add_to(mapa_sl_contra_mulher)

# Adicionar controle de camadas
folium.LayerControl().add_to(mapa_sl_contra_mulher)

# Exibir o mapa
mapa_sl_contra_mulher

"""## üìâ **An√°lises**

### **Porcentagem de Crimes Cometidos contra Mulheres por Bairro**
"""

# Filtrando o DataFrame para crimes cometidos contra mulheres
filtered_df = df_sl[~df_sl['Classifica√ß√£o Seguran√ßa Mulheres'].isin(['Outros', 'Furto/Roubo'])]

# Calculando a porcentagem de crimes por bairro
crime_percentage = filtered_df['Bairro Classifica√ß√£o'].value_counts(normalize=True) * 100

# Convertendo o resultado para um DataFrame
crime_percentage_df = crime_percentage.reset_index()
crime_percentage_df.columns = ['Bairro', 'Porcentagem de Crimes (%)']

# Criando uma paleta de cores em gradiente de laranja claro para vermelho vinho
cmap = mcolors.LinearSegmentedColormap.from_list("custom_gradient", ["#FF8524", "#6F0F13"])

# Normalizando os valores para mapear ao gradiente
norm = plt.Normalize(vmin=crime_percentage_df['Porcentagem de Crimes (%)'].min(), vmax=crime_percentage_df['Porcentagem de Crimes (%)'].max())
colors = [cmap(norm(value)) for value in crime_percentage_df['Porcentagem de Crimes (%)']]

# Criando o gr√°fico de barras com o gradiente aplicado aos valores
plt.figure(figsize=(16, 6))
bars = plt.bar(crime_percentage_df['Bairro'], crime_percentage_df['Porcentagem de Crimes (%)'], color=colors)
plt.xlabel('Bairro')
plt.ylabel('Porcentagem de Crimes (%)')
plt.xticks(rotation=45, ha='right')
plt.title('Porcentagem de Crimes Cometidos contra Mulheres por Bairro')
plt.ylim(0, crime_percentage_df['Porcentagem de Crimes (%)'].max() * 1.1)

# Adicionando as porcentagens acima de cada barra
for bar in bars:
    yval = bar.get_height()
    plt.text(bar.get_x() + bar.get_width() / 2, yval + 0.5, f'{yval:.2f}%', ha='center', va='bottom')

# Exibindo o gr√°fico
plt.show()

"""### **Total de Ocorr√™ncias contra a mulher por Tipo de Enquadramento**"""

# Filtrando o DataFrame para crimes cometidos contra mulheres
filtered_df = df_sl[~df_sl['Classifica√ß√£o Seguran√ßa Mulheres'].isin(['Outros', 'Furto/Roubo'])]

# Calculando o total de ocorr√™ncias por tipo de enquadramento
crime_counts = filtered_df['Classifica√ß√£o Seguran√ßa Mulheres'].value_counts()

# Convertendo o resultado para um DataFrame
crime_counts_df = crime_counts.reset_index()
crime_counts_df.columns = ['Tipo de Enquadramento', 'Total de Ocorr√™ncias']

# Criando uma paleta de cores em gradiente de laranja claro para vermelho vinho
cmap = mcolors.LinearSegmentedColormap.from_list("custom_gradient", ["#FF8524", "#6F0F13"])

# Normalizando os valores para mapear ao gradiente
norm = plt.Normalize(vmin=crime_counts_df['Total de Ocorr√™ncias'].min(), vmax=crime_counts_df['Total de Ocorr√™ncias'].max())
colors = [cmap(norm(value)) for value in crime_counts_df['Total de Ocorr√™ncias']]

# Criando o gr√°fico de barras com o gradiente aplicado aos valores
plt.figure(figsize=(12, 6))
bars = plt.bar(crime_counts_df['Tipo de Enquadramento'], crime_counts_df['Total de Ocorr√™ncias'], color=colors)
plt.xlabel('Tipo de Enquadramento')
plt.ylabel('Total de Ocorr√™ncias')
plt.xticks(rotation=45, ha='right')
plt.title('Total de Ocorr√™ncias por Tipo de Enquadramento')
plt.ylim(0, crime_counts_df['Total de Ocorr√™ncias'].max() * 1.1)

# Adicionando o n√∫mero de ocorr√™ncias em cima de cada barra
for bar in bars:
    yval = bar.get_height()
    plt.text(bar.get_x() + bar.get_width() / 2, yval + 0.5, f'{int(yval)}', ha='center', va='bottom')

# Exibindo o gr√°fico
plt.show()

"""### **Total de Ocorr√™ncias contra a mulher por Local**"""

# Filtrando o DataFrame para crimes cometidos contra mulheres
filtered_df = df_sl[~df_sl['Classifica√ß√£o Seguran√ßa Mulheres'].isin(['Outros', 'Furto/Roubo'])]

# Calculando o total de ocorr√™ncias por local do fato
crime_counts_local = filtered_df['Local Fato'].value_counts()

# Convertendo o resultado para um DataFrame para facilitar a plotagem
crime_counts_local_df = crime_counts_local.reset_index()
crime_counts_local_df.columns = ['Local Fato', 'Total de Ocorr√™ncias']

# Cores do gr√°fico, similares √†s do gr√°fico fornecido
colors = ["#6F0F13", "#BF1A1F", "#E64B21", "#FF8524", "#F3A932", "#F8D56B", "#FBE79F", "#FBF4D1"]

# Criando o gr√°fico de barras
plt.figure(figsize=(10, 6))
bars = plt.bar(crime_counts_local_df['Local Fato'], crime_counts_local_df['Total de Ocorr√™ncias'], color=colors[:len(crime_counts_local_df)])
plt.xlabel('Local do Fato')
plt.ylabel('Total de Ocorr√™ncias')
plt.xticks(rotation=45, ha='right')
plt.title('Total de Ocorr√™ncias por Local do Fato')

# Ajustando o limite do eixo Y para evitar sobreposi√ß√£o com o topo
plt.ylim(0, crime_counts_local_df['Total de Ocorr√™ncias'].max() * 1.1)

# Adicionando o total acima de cada barra
for bar in bars:
    yval = bar.get_height()
    plt.text(bar.get_x() + bar.get_width()/2, yval + 0.5, f'{int(yval)}', ha='center', va='bottom')

plt.show()

"""### **Total de Ocorr√™ncias de Feminic√≠dio**"""

# Filtrando os casos de feminic√≠dio
df_feminicidio = df_sl[df_sl['Classifica√ß√£o Seguran√ßa Mulheres'] == 'Feminicidio']

# Contando o n√∫mero de ocorr√™ncias de feminic√≠dio por bairro
feminicidio_counts = df_feminicidio['Bairro Classifica√ß√£o'].value_counts()

# Cores fornecidas para o gr√°fico
colors = ["#6F0F13", "#BF1A1F", "#E64B21", "#FF8524", "#F3A932", "#F8D56B", "#FBE79F", "#FBF4D1"]

# Criando o gr√°fico de barras com as cores especificadas
fig, ax = plt.subplots(figsize=(10, 6))
bars = ax.bar(feminicidio_counts.index, feminicidio_counts.values, color=colors[:len(feminicidio_counts)])

# Adicionando o n√∫mero de ocorr√™ncias em cima de cada barra
for bar in bars:
    height = bar.get_height()
    ax.text(bar.get_x() + bar.get_width() / 2, height, int(height), ha='center', va='bottom')

# Configurando r√≥tulos e t√≠tulo
ax.set_xlabel('Bairro Classifica√ß√£o')
ax.set_ylabel('Total de Ocorr√™ncias de Feminic√≠dio')
ax.set_title('Total de Ocorr√™ncias de Feminic√≠dio por Bairro')

# Exibindo o gr√°fico
plt.show()

"""### **Total de Ocorr√™ncias de Descumprimento de Medida Protetiva**"""

# Filtrando os casos de "Descumprimento de medida protetiva"
df_descumprimento = df_sl[df_sl['Classifica√ß√£o Seguran√ßa Mulheres'] == 'Descumprimento de medida protetiva']

# Contando o n√∫mero de ocorr√™ncias de descumprimento de medida protetiva por bairro
descumprimento_counts = df_descumprimento['Bairro Classifica√ß√£o'].value_counts()

# Ordenando os bairros pelo n√∫mero de ocorr√™ncias em ordem decrescente
sorted_counts = descumprimento_counts.sort_values(ascending=False)

# Criando uma paleta de cores em gradiente de vermelho vinho para laranja claro
cmap = mcolors.LinearSegmentedColormap.from_list("custom_gradient", ["#FF8524", "#6F0F13"])

# Normalizando os valores para mapear ao gradiente
norm = plt.Normalize(vmin=sorted_counts.min(), vmax=sorted_counts.max())
colors = [cmap(norm(value)) for value in sorted_counts.values]

# Criando o gr√°fico de barras com o gradiente aplicado aos valores
fig, ax = plt.subplots(figsize=(16, 6))
bars = ax.bar(sorted_counts.index, sorted_counts.values, color=colors)

# Adicionando o n√∫mero de ocorr√™ncias em cima de cada barra
for bar in bars:
    height = bar.get_height()
    ax.text(bar.get_x() + bar.get_width() / 2, height, int(height), ha='center', va='bottom')

# Configurando r√≥tulos e t√≠tulo
ax.set_xlabel('Bairro Classifica√ß√£o')
ax.set_ylabel('Total de Ocorr√™ncias de Descumprimento de Medida Protetiva')
ax.set_title('Total de Ocorr√™ncias de Descumprimento de Medida Protetiva por Bairro')
plt.xticks(rotation=45, ha='right')

# Exibindo o gr√°fico
plt.show()

"""### **Crimes por per√≠odo do dia**

üîπ **Crimes de Les√£o corporal por per√≠odo do dia**
"""

# Filtrar as ocorr√™ncias de "Les√£o corporal"
df_lesao_corporal = df_sl[df_sl['Classifica√ß√£o Seguran√ßa Mulheres'] == 'Lesao corporal']

# Contar o total de ocorr√™ncias por Per√≠odo do Dia
ocorrencias_por_periodo = df_lesao_corporal['Per√≠odo do Dia'].value_counts().sort_index()

cores = ['#800000', 'red', 'orange']

# Determinar as faixas para cada cor
max_val = ocorrencias_por_periodo.max()
min_val = ocorrencias_por_periodo.min()
intervalo = (max_val - min_val) / 3

# Fun√ß√£o para definir a cor com base no valor
def get_color(value):
    if value >= min_val + 2 * intervalo:
        return cores[0]
    elif value >= min_val + intervalo:
        return cores[1]
    else:
        return cores[2]

# Criar o gr√°fico de barras
plt.figure(figsize=(10, 6))
bars = plt.bar(ocorrencias_por_periodo.index,
               ocorrencias_por_periodo.values,
               color=[get_color(value) for value in ocorrencias_por_periodo.values])

plt.ylim(0, ocorrencias_por_periodo.values.max() * 1.2)

# Adicionar r√≥tulos e t√≠tulo
plt.xlabel('Per√≠odo do Dia', fontsize=14)
plt.ylabel('Total de Ocorr√™ncias', fontsize=14)
plt.title('Total de Ocorr√™ncias de Les√£o Corporal por Per√≠odo do Dia', fontsize=16)

# Adicionar os valores das ocorr√™ncias
for i, total in enumerate(ocorrencias_por_periodo.values):
    plt.text(i, total + 0.5, f'{total}', ha='center', va='bottom', fontsize=12)

# Exibir o gr√°fico
plt.tight_layout()
plt.show()

"""üîπ **Crimes de Estupro por per√≠odo do dia**"""

# Filtrar as ocorr√™ncias de "Estupro"
df_lesao_corporal = df_sl[df_sl['Classifica√ß√£o Seguran√ßa Mulheres'] == 'Estupro']

# Contar o total de ocorr√™ncias por Per√≠odo do Dia
ocorrencias_por_periodo = df_lesao_corporal['Per√≠odo do Dia'].value_counts().sort_index()

cores = ['#800000', 'red', 'orange']

# Determinar as faixas para cada cor
max_val = ocorrencias_por_periodo.max()
min_val = ocorrencias_por_periodo.min()
intervalo = (max_val - min_val) / 3

def get_color(value):
    if value >= min_val + 2 * intervalo:
        return cores[0]
    elif value >= min_val + intervalo:
        return cores[1]
    else:
        return cores[2]

# Criar o gr√°fico de barras
plt.figure(figsize=(10, 6))
bars = plt.bar(ocorrencias_por_periodo.index,
               ocorrencias_por_periodo.values,
               color=[get_color(value) for value in ocorrencias_por_periodo.values])

plt.ylim(0, ocorrencias_por_periodo.values.max() * 1.2)

# Adicionar r√≥tulos e t√≠tulo
plt.xlabel('Per√≠odo do Dia', fontsize=14)
plt.ylabel('Total de Ocorr√™ncias', fontsize=14)
plt.title('Total de Ocorr√™ncias de Estupro por Per√≠odo do Dia', fontsize=16)

# Adicionar os valores das ocorr√™ncias
for i, total in enumerate(ocorrencias_por_periodo.values):
    plt.text(i, total + 0.5, f'{total}', ha='center', va='bottom', fontsize=12)

# Exibir o gr√°fico
plt.tight_layout()
plt.show()

"""üîπ **Crimes de Estupro de vulner√°vel por per√≠odo do dia**"""

# Filtrar as ocorr√™ncias de "Estupro de vulner√°vel"
df_lesao_corporal = df_sl[df_sl['Classifica√ß√£o Seguran√ßa Mulheres'] == 'Estupro de vulneravel']

# Contar o total de ocorr√™ncias por Per√≠odo do Dia
ocorrencias_por_periodo = df_lesao_corporal['Per√≠odo do Dia'].value_counts().sort_index()

# Definir cores e intervalo para a colora√ß√£o
cores = ['#800000', 'red', 'orange']
max_val = ocorrencias_por_periodo.max()
min_val = ocorrencias_por_periodo.min()
intervalo = (max_val - min_val) / 3

# Fun√ß√£o para determinar a cor
def get_color(value):
    if value >= min_val + 2 * intervalo:
        return cores[0]
    elif value >= min_val + intervalo:
        return cores[1]
    else:
        return cores[2]

# Ajustar o limite do eixo Y para ser mais longo (aumento de 50%)
y_max_extended = ocorrencias_por_periodo.values.max() * 1.1

# Criar o gr√°fico de barras com o eixo Y ajustado
plt.figure(figsize=(10, 6))
bars = plt.bar(ocorrencias_por_periodo.index,
               ocorrencias_por_periodo.values,
               color=[get_color(value) for value in ocorrencias_por_periodo.values])

# Definir o limite superior do eixo Y
plt.ylim(0, y_max_extended)

# Adicionar r√≥tulos e t√≠tulo
plt.xlabel('Per√≠odo do Dia', fontsize=14)
plt.ylabel('Total de Ocorr√™ncias', fontsize=14)
plt.title('Total de Ocorr√™ncias de Estupro de vulneravel por Per√≠odo do Dia', fontsize=16)

# Adicionar os valores das ocorr√™ncias
for i, total in enumerate(ocorrencias_por_periodo.values):
    plt.text(i, total + 0.5, f'{total}', ha='center', va='bottom', fontsize=12)

# Exibir o gr√°fico
plt.tight_layout()
plt.show()

"""### **Crimes por local**

üîπ **Crimes contra a mulher por local**
"""

# Filtrar apenas os casos contra mulheres
df_contra_mulheres = df_sl[(df_sl['Classifica√ß√£o Seguran√ßa Mulheres'] != 'Outros') &
                           (df_sl['Classifica√ß√£o Seguran√ßa Mulheres'] != 'Furto/Roubo')]

# Contar o total de casos por Local Fato
total_casos_por_local = df_contra_mulheres['Local Fato'].value_counts().reset_index()
total_casos_por_local.columns = ['Local Fato', 'Total de Casos']

# Ordenar os dados do maior para o menor para uma melhor visualiza√ß√£o
total_casos_por_local = total_casos_por_local.sort_values(by='Total de Casos', ascending=False)

cmap = plt.cm.get_cmap("YlOrRd")

# Normalizar os valores para aplicar o gradiente de cores
norm = mcolors.Normalize(vmin=total_casos_por_local['Total de Casos'].min(),
                         vmax=total_casos_por_local['Total de Casos'].max())

# Criar o gr√°fico de barras
plt.figure(figsize=(16, 6))
bars = plt.bar(total_casos_por_local['Local Fato'],
               total_casos_por_local['Total de Casos'],
               color=[cmap(norm(value)) for value in total_casos_por_local['Total de Casos']])

plt.ylim(0, total_casos_por_local['Total de Casos'].max() * 1.2)

# Adicionar r√≥tulos e t√≠tulo
plt.xlabel('Local do Fato', fontsize=14)
plt.ylabel('Total de Casos', fontsize=14)
plt.title('Total de Casos contra Mulheres por Local do Fato', fontsize=16)
plt.xticks(rotation=45, ha='right')

# Adicionar os valores dos casos
for i, total in enumerate(total_casos_por_local['Total de Casos']):
    plt.text(i, total + 5, f'{total}', ha='center', va='bottom', fontsize=10)

# Ajustar o layout e exibir o gr√°fico
plt.tight_layout()
plt.show()

"""üîπ **Crimes de Les√£o corporal por local**"""

# Filtrar apenas os casos de "Lesao corporal" e "Lesao corporal leve"
df_lesao = df_sl[df_sl['Classifica√ß√£o Seguran√ßa Mulheres'].isin(['Lesao corporal', 'Lesao corporal leve'])]

# Contar o total de casos por Local Fato
total_casos_por_local = df_lesao['Local Fato'].value_counts().reset_index()
total_casos_por_local.columns = ['Local Fato', 'Total de Casos']

# Calcular o total geral de casos para calcular a porcentagem
total_geral_casos = total_casos_por_local['Total de Casos'].sum()

# Criar o gr√°fico de barras
plt.figure(figsize=(6, 6))
bars = plt.bar(total_casos_por_local['Local Fato'], total_casos_por_local['Total de Casos'], color='coral')

# Adicionar r√≥tulos e t√≠tulo
plt.xlabel('Local do Fato', fontsize=14)
plt.ylabel('Total de Casos', fontsize=14)
plt.title('Total de Casos de Les√£o Corporal e Les√£o Corporal Leve por Local', fontsize=16)
plt.xticks(rotation=45, ha='right')

# Adicionar a porcentagem
for i, total in enumerate(total_casos_por_local['Total de Casos']):
    porcentagem = (total / total_geral_casos) * 100
    plt.text(i, total + 1, f'{porcentagem:.2f}%', ha='center', va='bottom', fontsize=10)

# Ajustar o layout e exibir o gr√°fico
plt.ylim(0, total_casos_por_local['Total de Casos'].max() * 1.2)
plt.tight_layout()
plt.show()

"""üîπ **Crimes de Estupro por local**"""

# Filtrar apenas os casos de "Estupro"
df_estupro = df_sl[df_sl['Classifica√ß√£o Seguran√ßa Mulheres'] == 'Estupro']

# Contar o total de casos por Local Fato
total_casos_por_local = df_estupro['Local Fato'].value_counts().reset_index()
total_casos_por_local.columns = ['Local Fato', 'Total de Casos']

# Calcular o total geral de casos para calcular a porcentagem
total_geral_casos = total_casos_por_local['Total de Casos'].sum()

# Criar o gr√°fico de barras
plt.figure(figsize=(8, 6))
bars = plt.bar(total_casos_por_local['Local Fato'], total_casos_por_local['Total de Casos'], color='coral')

# Adicionar r√≥tulos e t√≠tulo
plt.xlabel('Local do Fato', fontsize=14)
plt.ylabel('Total de Casos', fontsize=14)
plt.title('Total de Casos de Estupro por Local', fontsize=16)
plt.xticks(rotation=45, ha='right')

# Adicionar a porcentagem
for i, total in enumerate(total_casos_por_local['Total de Casos']):
    porcentagem = (total / total_geral_casos) * 100
    plt.text(i, total + 1, f'{porcentagem:.2f}%', ha='center', va='bottom', fontsize=10)

# Ajustar o layout e exibir o gr√°fico
plt.ylim(0, total_casos_por_local['Total de Casos'].max() * 1.2)
plt.tight_layout()
plt.show()

"""üîπ **Crimes de Estupro de vulner√°vel por local**"""

# Filtrar apenas os casos de "Estupro de vulneravel"
df_estupro_vulneravel = df_sl[df_sl['Classifica√ß√£o Seguran√ßa Mulheres'] == 'Estupro de vulneravel']

# Contar o total de casos por Local Fato
total_casos_por_local = df_estupro_vulneravel['Local Fato'].value_counts().reset_index()
total_casos_por_local.columns = ['Local Fato', 'Total de Casos']

# Calcular o total geral de casos para calcular a porcentagem
total_geral_casos = total_casos_por_local['Total de Casos'].sum()

# Criar o gr√°fico de barras
plt.figure(figsize=(10, 6))
bars = plt.bar(total_casos_por_local['Local Fato'], total_casos_por_local['Total de Casos'], color='coral')

# Adicionar r√≥tulos e t√≠tulo
plt.xlabel('Local do Fato', fontsize=14)
plt.ylabel('Total de Casos', fontsize=14)
plt.title('Total de Casos de Estupro de vulner√°vel por Local', fontsize=16)
plt.xticks(rotation=45, ha='right')

# Adicionar a porcentagem
for i, total in enumerate(total_casos_por_local['Total de Casos']):
    porcentagem = (total / total_geral_casos) * 100
    plt.text(i, total + 1, f'{porcentagem:.2f}%', ha='center', va='bottom', fontsize=10)

# Ajustar o layout e exibir o gr√°fico
plt.ylim(0, total_casos_por_local['Total de Casos'].max() * 1.2)
plt.tight_layout()
plt.show()

"""# ‚òÅ **Nuvem de palavras**"""

from wordcloud import WordCloud
from matplotlib.colors import LinearSegmentedColormap
import random

"""### üîπ **Nuvem de Palavras dos Bairros com Maior Incid√™ncia de Estupro e Estupro de Vulner√°vel**"""

# Filtrar apenas os crimes de 'Estupro' e 'Estupro de vulneravel'
df_estupro = df_sl[df_sl['Classifica√ß√£o Seguran√ßa Mulheres'].isin(['Estupro', 'Estupro de vulneravel'])]

# Contar a frequ√™ncia de cada bairro para esses crimes
bairro_counts = df_estupro['Bairro Classifica√ß√£o'].value_counts()

# Definir uma paleta personalizada de rosa mais intensa
pink_colors = LinearSegmentedColormap.from_list("custom_pink", ["#ffb6c1", "#ff69b4", "#ff1493", "#db0073"])

wordcloud = WordCloud(
    width=1000,
    height=600,
    background_color='white',
    colormap=pink_colors,
    relative_scaling=0.5,
    max_font_size=150,
    min_font_size=10,
    font_path=None,
    prefer_horizontal=1.0
).generate_from_frequencies(bairro_counts)

# Exibir a nuvem de palavras
plt.figure(figsize=(12, 8))
plt.imshow(wordcloud, interpolation='bilinear')
plt.axis('off')
plt.title('Nuvem de Palavras dos Bairros com Maior Incid√™ncia de Estupro e Estupro de Vulner√°vel', fontsize=16, fontweight='bold')
plt.show()

"""### üîπ **Nuvem de Palavras dos Bairros com Maior Incid√™ncia de Importunacao sexual e Assedio sexual**"""

# Filtrar apenas os crimes de 'Importunacao sexual' e 'Assedio sexual'
df_importunacao_estupro_sexual = df_sl[df_sl['Classifica√ß√£o Seguran√ßa Mulheres'].isin(['Importunacao sexual', 'Assedio sexual'])]

# Contar a frequ√™ncia de cada bairro para esses crimes
bairro_counts = df_importunacao_estupro_sexual['Bairro Classifica√ß√£o'].value_counts()

# Definir uma paleta personalizada de verdes
green_colors = LinearSegmentedColormap.from_list("custom_green", ["#a8e6cf", "#00ff00", "#32cd32", "#228b22", "#006400"])

wordcloud = WordCloud(
    width=1000,
    height=600,
    background_color='white',
    colormap=green_colors,
    relative_scaling=0.5,
    max_font_size=150,
    min_font_size=10,
    prefer_horizontal=1.0
).generate_from_frequencies(bairro_counts)

# Exibir a nuvem de palavras
plt.figure(figsize=(12, 8))
plt.imshow(wordcloud, interpolation='bilinear')
plt.axis('off')
plt.title('Nuvem de Palavras dos Bairros com Maior Incid√™ncia de Importunacao sexual e Assedio sexual', fontsize=16, fontweight='bold')
plt.show()

"""### üîπ **Nuvem de Palavras dos Bairros com Maior Incid√™ncia de Descumprimento de medida protetiva**"""

# Filtrar apenas os crimes de 'Descumprimento de medida protetiva'
df_descumprimento = df_sl[df_sl['Classifica√ß√£o Seguran√ßa Mulheres'] == 'Descumprimento de medida protetiva']

# Contar a frequ√™ncia de cada bairro para esses crimes
bairro_counts = df_descumprimento['Bairro Classifica√ß√£o'].value_counts()

# Definir uma paleta personalizada de tons de azul
blue_colors = LinearSegmentedColormap.from_list("custom_blue", ["#add8e6", "#87ceeb", "#4682b4", "#1e90ff", "#00008b"])

# Fun√ß√£o para colorir as palavras com base na frequ√™ncia
def blue_color_func(word, font_size, position, orientation, random_state=None, **kwargs):
    # Quanto maior a palavra, mais escura a cor
    if font_size > 100:
        return "#00008b"
    elif font_size > 75:
        return "#1e90ff"
    elif font_size > 50:
        return "#4682b4"
    elif font_size > 25:
        return "#87ceeb"
    else:
        return "#add8e6"

wordcloud = WordCloud(
    width=1000,
    height=600,
    background_color='white',
    color_func=blue_color_func,  # Aplica a fun√ß√£o de cor personalizada
    relative_scaling=0.5,       # Escala relativa para dar destaque a palavras maiores
    max_font_size=150,          # Aumenta o tamanho m√°ximo da fonte
    min_font_size=10,           # Define o tamanho m√≠nimo da fonte
    prefer_horizontal=1.0       # Prefere palavras na horizontal para melhorar o impacto visual
).generate_from_frequencies(bairro_counts)

# Exibir a nuvem de palavras
plt.figure(figsize=(12, 8))
plt.imshow(wordcloud, interpolation='bilinear')
plt.axis('off')
plt.title('Nuvem de Palavras dos Bairros com Maior Incid√™ncia de Descumprimento de Medida Protetiva', fontsize=16, fontweight='bold')
plt.show()

"""# üìà **Deep learning - Crimes contra a mulher em S√£o Leopoldo**

### Edi√ß√µes
"""

# Filtrar apenas os crimes contra mulheres
df_mulheres = df_sl[
    (df_sl['Classifica√ß√£o Seguran√ßa Mulheres'] != 'Outros') &
    (df_sl['Classifica√ß√£o Seguran√ßa Mulheres'] != 'Furto/Roubo')]

# Agrupar e contar o n√∫mero de crimes contra mulheres por bairro classifica√ß√£o
bairros_contagem = (
    df_mulheres
    .groupby('Bairro Classifica√ß√£o')
    .size()
    .reset_index(name='Contagem_Casos')
)

# Fun√ß√£o de classifica√ß√£o de risco
def classificar_bairro(contagem):
    if contagem == 0:
        return 'Seguro'
    elif 1 <= contagem <= 10:
        return 'Seguro'
    elif 11 <= contagem <= 50:
        return 'Inseguro'
    else:
        return 'Muito Inseguro'

bairros_contagem['Classificacao_Risco'] = bairros_contagem[
    'Contagem_Casos'
].apply(classificar_bairro)

"""### **Aplica√ß√£o do modelo de aprendizado de m√°quina**"""

from sklearn.preprocessing import LabelEncoder

# Codificar a coluna de classifica√ß√£o de risco em valores num√©ricos
le = LabelEncoder()
bairros_contagem['Classificacao_Risco_Num'] = le.fit_transform(
    bairros_contagem['Classificacao_Risco']
)

from sklearn.model_selection import train_test_split

# Separar as features (contagem de casos) e # o target (classifica√ß√£o de risco num√©rico)
X = bairros_contagem[['Contagem_Casos']].values
y = bairros_contagem['Classificacao_Risco_Num'].values

# Dividir os dados em conjunto de treinamento e teste
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42
)

import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense

# Constru√ß√£o do modelo de deep learning fffffffffffffffffffffffffffffffffffffffffff
model = Sequential()
model.add(Dense(64, input_dim=X_train.shape[1], activation='relu'))
model.add(Dense(32, activation='relu'))
model.add(Dense(16, activation='relu'))
model.add(Dense(3, activation='softmax'))

# Compila√ß√£o do modelo
model.compile(
    optimizer='adam',
    loss='sparse_categorical_crossentropy',
    metrics=['accuracy']
)

# Treinamento do modelo
history = model.fit(
    X_train,
    y_train,
    epochs=50,
    batch_size=8,
    validation_data=(X_test, y_test)
)

# Avalia√ß√£o do modelo
loss, accuracy = model.evaluate(X_test, y_test)
print(f'Acur√°cia do modelo: {accuracy * 100:.2f}%')

# Exibir o mapeamento da classifica√ß√£o
mapping = dict(zip(le.classes_, le.transform(le.classes_)))
print("Mapping de Classifica√ß√£o:", mapping)

"""### **Gr√°ficos**

üîπ **Bairros por Classifica√ß√£o de Risco**
"""

# Contar o n√∫mero de bairros por Classificacao_Risco
bairros_por_risco = bairros_contagem.groupby('Classificacao_Risco')['Bairro Classifica√ß√£o'].count().reset_index()
bairros_por_risco.columns = ['Classificacao_Risco', 'Quantidade_Bairros']

cores = ['#8B0000', 'red', 'orange', 'yellow']

# Criar o gr√°fico de barras
plt.figure(figsize=(10, 6))
bars = plt.bar(bairros_por_risco['Classificacao_Risco'],
               bairros_por_risco['Quantidade_Bairros'],
               color=cores[:len(bairros_por_risco)])  # Aplica as cores

plt.ylim(0, bairros_por_risco['Quantidade_Bairros'].max() * 1.2)

# Adicionar r√≥tulos e t√≠tulo
plt.xlabel('Classifica√ß√£o de Risco', fontsize=14)
plt.ylabel('N√∫mero de Bairros', fontsize=14)
plt.title('N√∫mero de Bairros por Classifica√ß√£o de Risco', fontsize=16)

# Adicionar os valores no topo de cada barra
for i, total in enumerate(bairros_por_risco['Quantidade_Bairros']):
    plt.text(i, total + 0.1, f'{total}', ha='center', va='bottom', fontsize=12)

# Ajustar o layout e exibir o gr√°fico
plt.tight_layout()
plt.show()

"""üîπ **Bairros classificados como Muito Inseguros**"""

# Filtrar e ordenar os bairros classificados como "Muito Inseguro" pelo n√∫mero de casos
bairros_muito_inseguros = bairros_contagem[bairros_contagem['Classificacao_Risco'] == 'Muito Inseguro']
bairros_muito_inseguros = bairros_muito_inseguros.sort_values(by='Contagem_Casos', ascending=False)

cmap = plt.cm.get_cmap("YlOrRd")
norm = mcolors.Normalize(vmin=bairros_muito_inseguros['Contagem_Casos'].min() * 0.5,
                         vmax=bairros_muito_inseguros['Contagem_Casos'].max())

plt.figure(figsize=(16, 6))
bars = plt.bar(bairros_muito_inseguros['Bairro Classifica√ß√£o'],
               bairros_muito_inseguros['Contagem_Casos'],
               color=[cmap(norm(value)) for value in bairros_muito_inseguros['Contagem_Casos']])

plt.ylim(0, bairros_muito_inseguros['Contagem_Casos'].max() * 1.2)

# Adicionar r√≥tulos e t√≠tulo
plt.xlabel('Bairro', fontsize=14)
plt.ylabel('Total de Casos', fontsize=14)
plt.title('Total de Casos por Bairro Classificado como Muito Inseguro', fontsize=16)
plt.xticks(rotation=45, ha='right')

# Adicionar os valores dos casos no topo de cada barra
for i, total in enumerate(bairros_muito_inseguros['Contagem_Casos']):
    plt.text(i, total + 0.5, f'{total}', ha='center', va='bottom', fontsize=10)

# Ajustar o layout e exibir o gr√°fico
plt.tight_layout()
plt.show()

"""üîπ **Bairros classificados como Inseguros**"""

# Filtrar e ordenar os bairros classificados como "Inseguro" pelo n√∫mero de casos
bairros_inseguros = bairros_contagem[bairros_contagem['Classificacao_Risco'] == 'Inseguro']
bairros_inseguros = bairros_inseguros.sort_values(by='Contagem_Casos', ascending=False)

plt.figure(figsize=(12, 6))
bars = plt.bar(bairros_inseguros['Bairro Classifica√ß√£o'],
               bairros_inseguros['Contagem_Casos'],
               color='orange')

plt.ylim(0, bairros_inseguros['Contagem_Casos'].max() * 1.2)

# Adicionar r√≥tulos e t√≠tulo
plt.xlabel('Bairro', fontsize=14)
plt.ylabel('Total de Casos', fontsize=14)
plt.title('Total de Casos por Bairro Classificado como Inseguro', fontsize=16)
plt.xticks(rotation=45, ha='right')

# Adicionar os valores dos casos no topo de cada barra
for i, total in enumerate(bairros_inseguros['Contagem_Casos']):
    plt.text(i, total + 0.1, f'{total}', ha='center', va='bottom', fontsize=10)

# Ajustar o layout e exibir o gr√°fico
plt.tight_layout()
plt.show()

"""üîπ **Bairros classificados como Seguros**"""

# Filtrar e ordenar os bairros classificados como "Seguro" pelo n√∫mero de casos
bairros_seguros = bairros_contagem[bairros_contagem['Classificacao_Risco'] == 'Seguro']
bairros_seguros = bairros_seguros.sort_values(by='Contagem_Casos', ascending=False)

plt.figure(figsize=(8, 6))
bars = plt.bar(bairros_seguros['Bairro Classifica√ß√£o'],
               bairros_seguros['Contagem_Casos'],
               color='yellow')

plt.ylim(0, bairros_seguros['Contagem_Casos'].max() * 1.5)

# Adicionar r√≥tulos e t√≠tulo
plt.xlabel('Bairro', fontsize=14)
plt.ylabel('Total de Casos', fontsize=14)
plt.title('Total de Casos por Bairro Classificado como Seguro', fontsize=16)
plt.xticks(rotation=45, ha='right')

# Adicionar os valores dos casos no topo de cada barra
for i, total in enumerate(bairros_seguros['Contagem_Casos']):
    plt.text(i, total + 0.1, f'{total}', ha='center', va='bottom', fontsize=10)

# Ajustar o layout e exibir o gr√°fico
plt.tight_layout()
plt.show()

"""# **Clusteriza√ß√£o**"""

from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler
from datetime import datetime

"""### üîπ **Crimes de Importunacao sexual e Assedio sexual**"""

# Filtrar apenas os crimes de 'Importunacao sexual' e 'Assedio sexual'
df_filtered = df_sl[df_sl['Classifica√ß√£o Seguran√ßa Mulheres'].isin(['Importunacao sexual', 'Assedio sexual'])]

# Selecionar apenas as colunas de interesse: 'Idade V√≠tima' e 'Bairro Classifica√ß√£o'
df_importunacao_assedio = df_filtered[['Idade V√≠tima', 'Bairro Classifica√ß√£o']].dropna()

# Padronizar a coluna de Idade para o KMeans
scaler = StandardScaler()
idade_scaled = scaler.fit_transform(df_importunacao_assedio[['Idade V√≠tima']])

# Definir o n√∫mero de clusters
k = 3
kmeans = KMeans(n_clusters=k, random_state=42)
df_importunacao_assedio['Cluster'] = kmeans.fit_predict(idade_scaled)

# Criar o DataFrame df_idade
df_idade_importunacao_assedio = df_importunacao_assedio[['Idade V√≠tima', 'Cluster']]

# Adicionar os centros dos clusters como refer√™ncia
cluster_centers = scaler.inverse_transform(kmeans.cluster_centers_)
df_idade_importunacao_assedio['Cluster Center'] = df_idade_importunacao_assedio['Cluster'].map(lambda x: cluster_centers[x][0])

# Exibir os resultados por cluster
resultado_cluster = df_idade_importunacao_assedio.groupby('Cluster').agg({'Idade V√≠tima': ['mean', 'min', 'max', 'count']})
resultado_cluster

# Gerando o gr√°fico de histograma com valores no eixo x pulando de 5 em 5
plt.figure(figsize=(12, 6))
plt.hist(df_idade_importunacao_assedio['Idade V√≠tima'], bins=20, color='skyblue', edgecolor='black')
plt.title('Distribui√ß√£o de Idades das V√≠timas por Cluster')
plt.xlabel('Idade da V√≠tima')
plt.ylabel('Frequ√™ncia')

plt.xticks(range(8, 80, 2))
plt.show()

# Padronizar a coluna 'Idade V√≠tima' para clustering
scaler = StandardScaler()
idade_scaled = scaler.fit_transform(df_idade_importunacao_assedio[['Idade V√≠tima']])

# Calcular a in√©rcia para diferentes n√∫meros de clusters
inertias = []
k_values = range(1, 10)

for k in k_values:
    kmeans = KMeans(n_clusters=k, random_state=42)
    kmeans.fit(idade_scaled)
    inertias.append(kmeans.inertia_)

# Plotar o gr√°fico do m√©todo do cotovelo
plt.figure(figsize=(8, 6))
plt.plot(k_values, inertias, marker='o')
plt.title('M√©todo do Cotovelo para Determina√ß√£o do N√∫mero Ideal de Clusters')
plt.xlabel('N√∫mero de Clusters (k)')
plt.ylabel('In√©rcia')
plt.show()

# Criar o gr√°fico de dispers√£o para a distribui√ß√£o dos clusters de acordo com a idade (Importuna√ß√£o Sexual e Ass√©dio Sexual)
plt.figure(figsize=(10, 6))
scatter = plt.scatter(df_idade_importunacao_assedio['Idade V√≠tima'], df_idade_importunacao_assedio['Cluster'],
                      c=df_idade_importunacao_assedio['Cluster'], cmap='viridis', s=50, alpha=0.7, edgecolor='k')
plt.colorbar(scatter, label='Cluster')
plt.title('Distribui√ß√£o dos Clusters de Idade para Casos de Importuna√ß√£o Sexual e Ass√©dio Sexual')
plt.xlabel('Idade da V√≠tima')
plt.ylabel('Cluster de Idade')
plt.yticks(ticks=range(df_idade_importunacao_assedio['Cluster'].nunique()),
           labels=[f'Cluster {i}' for i in range(df_idade_importunacao_assedio['Cluster'].nunique())])

plt.show()

"""### üîπ **Crimes de Les√£o corporal**"""

# Filtrar apenas os crimes de 'Lesao Corporal' e 'Lesao Corporal Leve'
df_filtered_lesao = df_sl[df_sl['Classifica√ß√£o Seguran√ßa Mulheres'].isin(['Lesao corporal', 'Lesao corporal leve'])]

# Selecionar apenas as colunas de interesse: 'Idade V√≠tima' e 'Bairro Classifica√ß√£o'
df_lesao_corporal = df_filtered_lesao[['Idade V√≠tima', 'Bairro Classifica√ß√£o']].dropna()

# Padronizar a coluna de Idade para o KMeans
scaler = StandardScaler()
idade_scaled_lesao = scaler.fit_transform(df_lesao_corporal[['Idade V√≠tima']])

# Definir o n√∫mero de clusters
k = 3
kmeans = KMeans(n_clusters=k, random_state=42)
df_lesao_corporal['Cluster'] = kmeans.fit_predict(idade_scaled_lesao)

# Criar o DataFrame df_idade_lesao
df_idade_lesao = df_lesao_corporal[['Idade V√≠tima', 'Cluster']]

# Adicionar os centros dos clusters como refer√™ncia
cluster_centers_lesao = scaler.inverse_transform(kmeans.cluster_centers_)
df_idade_lesao['Cluster Center'] = df_idade_lesao['Cluster'].map(lambda x: cluster_centers_lesao[x][0])

# Exibir os resultados por cluster
resultado_cluster_lesao = df_idade_lesao.groupby('Cluster').agg({'Idade V√≠tima': ['mean', 'min', 'max', 'count']})
resultado_cluster_lesao

# Visualiza√ß√£o dos clusters de idade para Les√£o Corporal
plt.figure(figsize=(16, 6))
plt.hist(df_idade_lesao['Idade V√≠tima'], bins=20, color='skyblue', edgecolor='black')
plt.title('Distribui√ß√£o de Idades das V√≠timas de Les√£o Corporal por Cluster')
plt.xlabel('Idade da V√≠tima')
plt.ylabel('Frequ√™ncia')

plt.xticks(range(2, 83, 2))
plt.show()

# Padronizar a coluna 'Idade V√≠tima' para clustering
idade_scaled_lesao = scaler.fit_transform(df_idade_lesao[['Idade V√≠tima']])

# Calcular a in√©rcia para diferentes n√∫meros de clusters
inertias_lesao = []
k_values = range(1, 10)

for k in k_values:
    kmeans = KMeans(n_clusters=k, random_state=42)
    kmeans.fit(idade_scaled_lesao)
    inertias_lesao.append(kmeans.inertia_)

# Plotar o gr√°fico do m√©todo do cotovelo para Les√£o Corporal
plt.figure(figsize=(8, 6))
plt.plot(k_values, inertias_lesao, marker='o')
plt.title('M√©todo do Cotovelo para Determina√ß√£o do N√∫mero Ideal de Clusters (Les√£o Corporal)')
plt.xlabel('N√∫mero de Clusters (k)')
plt.ylabel('In√©rcia')
plt.show()

# Criar o gr√°fico de dispers√£o para a distribui√ß√£o dos clusters de acordo com a idade (Les√£o Corporal)
plt.figure(figsize=(10, 6))
scatter = plt.scatter(df_idade_lesao['Idade V√≠tima'], df_idade_lesao['Cluster'],
                      c=df_idade_lesao['Cluster'], cmap='viridis', s=50, alpha=0.7, edgecolor='k')
plt.colorbar(scatter, label='Cluster')
plt.title('Distribui√ß√£o dos Clusters de Idade para Casos de Les√£o Corporal')
plt.xlabel('Idade da V√≠tima')
plt.ylabel('Cluster de Idade')
plt.yticks(ticks=range(df_idade_lesao['Cluster'].nunique()),
           labels=[f'Cluster {i}' for i in range(df_idade_lesao['Cluster'].nunique())])

plt.show()

"""### üîπ **Crimes de Estupro**"""

# Filtrar apenas os crimes de 'Estupro' e 'Estupro de Vulner√°vel'
df_filtered_estupro = df_sl[df_sl['Classifica√ß√£o Seguran√ßa Mulheres'].isin(['Estupro', 'Estupro de vulneravel'])]

# Selecionar apenas as colunas de interesse: 'Idade V√≠tima' e 'Bairro Classifica√ß√£o'
df_estupro = df_filtered_estupro[['Idade V√≠tima', 'Bairro Classifica√ß√£o']].dropna()

if df_estupro.shape[0] > 0:
    # Padronizar a coluna de Idade para o KMeans
    scaler = StandardScaler()
    idade_scaled_estupro = scaler.fit_transform(df_estupro[['Idade V√≠tima']])

# Definir o n√∫mero de clusters
k = 4
kmeans = KMeans(n_clusters=k, random_state=42)
df_estupro['Cluster'] = kmeans.fit_predict(idade_scaled_estupro)

# Criar o DataFrame df_idade_estupro
df_idade_estupro = df_estupro[['Idade V√≠tima', 'Cluster']]

# Adicionar os centros dos clusters como refer√™ncia
cluster_centers_estupro = scaler.inverse_transform(kmeans.cluster_centers_)
df_idade_estupro['Cluster Center'] = df_idade_estupro['Cluster'].map(lambda x: cluster_centers_estupro[x][0])

# Exibir os resultados por cluster
resultado_cluster_estupro = df_idade_estupro.groupby('Cluster').agg({'Idade V√≠tima': ['mean', 'min', 'max', 'count']})
resultado_cluster_estupro

# Visualiza√ß√£o dos clusters de idade para Estupro
plt.figure(figsize=(16, 6))
plt.hist(df_idade_estupro['Idade V√≠tima'], bins=20, color='skyblue', edgecolor='black')
plt.title('Distribui√ß√£o de Idades das V√≠timas de Estupro por Cluster')
plt.xlabel('Idade da V√≠tima')
plt.ylabel('Frequ√™ncia')

plt.xticks(range(0, 90, 2))

plt.show()

# Padronizar a coluna 'Idade V√≠tima' para clustering
idade_scaled_estupro = scaler.fit_transform(df_idade_estupro[['Idade V√≠tima']])

# Calcular a in√©rcia para diferentes n√∫meros de clusters
inertias_estupro = []
k_values = range(1, 10)

for k in k_values:
    kmeans = KMeans(n_clusters=k, random_state=42)
    kmeans.fit(idade_scaled_estupro)
    inertias_estupro.append(kmeans.inertia_)

# Plotar o gr√°fico do m√©todo do cotovelo para Estupro
plt.figure(figsize=(8, 6))
plt.plot(k_values, inertias_estupro, marker='o')
plt.title('M√©todo do Cotovelo para Determina√ß√£o do N√∫mero Ideal de Clusters (Estupro)')
plt.xlabel('N√∫mero de Clusters (k)')
plt.ylabel('In√©rcia')
plt.show()

# Criar o gr√°fico de dispers√£o para a distribui√ß√£o dos clusters de acordo com a idade
plt.figure(figsize=(10, 6))
scatter = plt.scatter(df_idade_estupro['Idade V√≠tima'], df_idade_estupro['Cluster'],
                      c=df_idade_estupro['Cluster'], cmap='viridis', s=50, alpha=0.7, edgecolor='k')
plt.colorbar(scatter, label='Cluster')
plt.title('Distribui√ß√£o dos Clusters de Idade para Casos de Estupro e Estupro de Vulner√°vel')
plt.xlabel('Idade da V√≠tima')
plt.ylabel('Cluster de Idade')
plt.yticks(ticks=range(df_idade_estupro['Cluster'].nunique()), labels=[f'Cluster {i}' for i in range(df_idade_estupro['Cluster'].nunique())])

plt.show()